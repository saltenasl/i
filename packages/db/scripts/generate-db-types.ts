import { writeFile } from 'node:fs/promises';
import path from 'node:path';
import { DatabaseSync } from 'node:sqlite';

interface TableRow {
  name: string;
}

interface ColumnRow {
  name: string;
  type: string;
  notnull: number;
  pk: number;
}

const asRecord = (value: unknown): Record<string, unknown> => {
  if (typeof value !== 'object' || value === null || Array.isArray(value)) {
    throw new Error(`Expected object row but received ${typeof value}.`);
  }

  return value as Record<string, unknown>;
};

const asString = (value: unknown, field: string): string => {
  if (typeof value !== 'string') {
    throw new Error(`Expected "${field}" to be a string.`);
  }

  return value;
};

const asNumber = (value: unknown, field: string): number => {
  if (typeof value !== 'number') {
    throw new Error(`Expected "${field}" to be a number.`);
  }

  return value;
};

const parseTableRows = (rows: unknown[]): TableRow[] => {
  return rows.map((raw) => {
    const record = asRecord(raw);
    return {
      name: asString(record.name, 'name'),
    };
  });
};

const parseColumnRows = (rows: unknown[]): ColumnRow[] => {
  return rows.map((raw) => {
    const record = asRecord(raw);
    return {
      name: asString(record.name, 'name'),
      type: typeof record.type === 'string' ? record.type : 'TEXT',
      notnull: asNumber(record.notnull, 'notnull'),
      pk: asNumber(record.pk, 'pk'),
    };
  });
};

const mapSqliteTypeToTs = (rawType: string): string => {
  const upper = rawType.toUpperCase();

  if (upper.includes('INT')) {
    return 'number';
  }

  if (upper.includes('CHAR') || upper.includes('CLOB') || upper.includes('TEXT')) {
    return 'string';
  }

  if (upper.includes('BLOB')) {
    return 'Uint8Array';
  }

  if (
    upper.includes('REAL') ||
    upper.includes('FLOA') ||
    upper.includes('DOUB') ||
    upper.includes('NUMERIC')
  ) {
    return 'number';
  }

  return 'string';
};

const toPascalCase = (value: string): string => {
  const normalized = value
    .replace(/^_+/, '')
    .replace(/[^a-zA-Z0-9]+/g, ' ')
    .trim();
  if (normalized.length === 0) {
    return 'Table';
  }

  const pascal = normalized
    .split(/\s+/)
    .map((segment) => segment.charAt(0).toUpperCase() + segment.slice(1).toLowerCase())
    .join('');

  return /^\d/.test(pascal) ? `T${pascal}` : pascal;
};

export const renderDatabaseTypes = (dbPath: string): string => {
  const sqlite = new DatabaseSync(dbPath, { readOnly: true });

  try {
    const tables = parseTableRows(
      sqlite
        .prepare(
          "SELECT name FROM sqlite_master WHERE type = 'table' AND name NOT LIKE 'sqlite_%' ORDER BY name ASC",
        )
        .all(),
    );

    const tableInterfaces: string[] = [];
    const tableTypePairs: string[] = [];

    for (const table of tables) {
      const columns = parseColumnRows(
        sqlite.prepare(`PRAGMA table_info(${JSON.stringify(table.name)})`).all(),
      );
      const interfaceName = `${toPascalCase(table.name)}Table`;

      const fields = columns
        .map((column) => {
          const base = mapSqliteTypeToTs(column.type || 'TEXT');
          const nullable = column.notnull === 0 && column.pk === 0;
          const fieldType = nullable ? `${base} | null` : base;
          return `  ${column.name}: ${fieldType};`;
        })
        .join('\n');

      tableInterfaces.push(`export interface ${interfaceName} {\n${fields}\n}`);
      tableTypePairs.push(`  ${table.name}: ${interfaceName};`);
    }

    return [
      '/* eslint-disable */',
      '// Generated by packages/db/scripts/generate-db-types.ts. Do not edit by hand.',
      '',
      ...tableInterfaces,
      '',
      'export interface Database {',
      ...tableTypePairs,
      '}',
      '',
    ].join('\n');
  } finally {
    sqlite.close();
  }
};

export const writeDatabaseTypes = async (dbPath: string, outputPath: string): Promise<void> => {
  const rendered = renderDatabaseTypes(dbPath);
  await writeFile(outputPath, rendered, 'utf-8');
};

const parseArg = (name: string): string | undefined => {
  const index = process.argv.findIndex((arg) => arg === name);
  if (index === -1) {
    return undefined;
  }

  return process.argv[index + 1];
};

if (import.meta.url === `file://${process.argv[1]}`) {
  const dbPath = parseArg('--db');
  const outPath = parseArg('--out');

  if (!dbPath || !outPath) {
    throw new Error('Usage: tsx packages/db/scripts/generate-db-types.ts --db <path> --out <path>');
  }

  const resolvedDb = path.resolve(dbPath);
  const resolvedOut = path.resolve(outPath);
  await writeDatabaseTypes(resolvedDb, resolvedOut);
}
